class A {
  volatile b: boolean

  a1(num: int): A {
    num_aux: int
    if (a3()) {
      num_aux := 1
    } else if (a2() < 1) {
      num_aux := num * a2()
    } else {
      num_aux := 0
    }
    return this //@error - semantic (invalid use of 'this' in C+-)
  }

  a2(): int {
    x: A
    y: A
    t: int
    ia: int[]
    ret: int
    aa: int

    // --- nested calls with wrong parameter TYPES ---

    b := a1(a3()).a3() //@error - semantic (invalid argument type for a1: expected int, got boolean)

    b := x.a1(y.a1(a4()).a4()).a3() //@error - semantic (invalid argument type for inner a1: expected int, got int from a4() ok, but y.a1(...) returns A, then .a4() invalid on A? see below)

    b := x.a1(y.a1(2).a3()).a3() //@error - semantic (invalid argument type for a1: expected int, got boolean from a3())

    // --- invalid member access / chaining (type errors) ---

    b := x.a1(y.a1(2).a4()).a2() //@error - semantic (invalid RHS: a2() returns int, cannot assign to boolean)

    aa := x.a2().a1(1) //@error - semantic (invalid member 'a1' on return type int of a2())

    // --- argument count / order mismatches for a5 ---

    t := a5(b, aa, ia, x) //@error - semantic (invalid 2nd parameter type: expected int, got int ok; but aa is int; keep one error per line below)

    t := a5(b, aa, ia) //@error - semantic (invalid number of parameters)

    t := a5(aa, b, ia, x) //@error - semantic (invalid order/types of parameters)

    t := a5(b, a3(), ia, x) //@error - semantic (invalid 2nd parameter type: expected int, got boolean)

    // some control-flow so method returns an int
    if (b) {
      ret := 1
    } else {
      ret := 0
    }
    return ret
  }

  a3(): boolean {
    return true
  }

  a4(): int {
    return 1
  }

  a5(p: boolean, q: int, r: int[], s: A): int {
    return 1
  }
}

main() : int {
  print(A().a1(1))
  print(A().a2())
  return 0
}